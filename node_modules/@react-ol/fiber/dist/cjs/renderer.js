"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.render = render;
var _react = _interopRequireDefault(require("react"));
var _reactReconciler = _interopRequireDefault(require("react-reconciler"));
var _scheduler = require("scheduler");
var _fp = require("lodash/fp");
var _catalogue = require("./catalogue");
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function _construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
var _this = void 0;
var MetaOlFiber = Symbol("MetaOlFiber");
// export type Reconciler = HostConfig<
//   Type,
//   Props,
//   Container,
//   Instance,
//   TextInstance,
//   HydratableInstance,
//   PublicInstance,
//   HostContext,
//   UpdatePayload,
//   ChildSet,
//   TimeoutHandle,
//   NoTimeout
// >;
var instances = new Map();
var emptyObject = {};
// eslint-disable-next-line @typescript-eslint/no-empty-function
var noOp = function() {};
var error002 = function() {
    var containerType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", childType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return new Error("React-Openlayers-Fiber Error: Couldn't add this child to this container. You can specify how to attach this type of child (\"".concat(childType, "\") to this type of container (\"").concat(containerType, "\") using the \"attach\" props. If you think this should be done automatically, open an issue here https://github.com/labelflow/react-openlayers-fiber/issues/new?title=Support+").concat(childType, "+in+").concat(containerType, "&body=Support+").concat(childType, "+in+").concat(containerType));
};
var error001 = function() {
    return new Error("React-Openlayers-Fiber Error: Instance is null, is it a TextInstance ?");
};
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
// Util functions
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
var applyProp = function(olObject, olKey, propValue) {
    var setterGeneric = olObject.set;
    var keySetter = "set".concat((0, _fp).upperFirst(olKey));
    var setterSpecificKey = olObject[keySetter];
    if ((0, _fp).isFunction(setterSpecificKey)) {
        setterSpecificKey.bind(olObject)(propValue);
    } else if ((0, _fp).isFunction(setterGeneric)) {
        setterGeneric.bind(olObject)(olKey, propValue);
    } else if ((0, _fp).has(olKey, olObject)) {
        console.warn("React-Openlayers-Fiber Warning: Setting the property \"".concat(olKey, "\" brutally because there is no setter on the object"));
        console.warn(olObject);
        // eslint-disable-next-line no-param-reassign
        (olObject)[olKey] = propValue;
    } else {
        console.error("React-Openlayers-Fiber Error: Setting the property \"".concat(olKey, "\" very brutally because there is no setter on the object nor the object has this key... This is probably an error"));
        console.error(olObject);
        // eslint-disable-next-line no-param-reassign
        (olObject)[olKey] = propValue;
    }
};
/**
 *
 * This code checks, for every given props,
 * if the ol entity has a setter for the prop.
 * If it has one, it sets the value to the ol object,
 * but it only sets it if it changed from the previous props.
 *
 * @param olObject The ol object to update
 * @param newProps The newProps potentially containing new changes
 */ var applyProps = function(olObject, newProps) {
    var oldProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, isNewInstance = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    (0, _fp).forEach(function(key) {
        if (isNewInstance && key.substr(0, 7) === "initial") {
            var realKey = (0, _fp).lowerFirst(key.substr(7));
            var olKey = (0, _fp).startsWith("_", realKey) ? realKey.substring(1) : realKey;
            applyProp(olObject, olKey, newProps[key]);
        } else if (oldProps[key] !== newProps[key] && key.substr(0, 7) !== "initial") {
            // For special cases (for example ol objects that have an option called "key"), we can add a "_" before.
            if (key.substr(0, 2) === "on") {
                var eventType = (0, _fp).lowerFirst(key.substr(2).replace("_", ":"));
                if ((0, _fp).isFunction(oldProps[key])) {
                    olObject.un(eventType, oldProps[key]);
                }
                if ((0, _fp).isFunction(newProps[key])) {
                    olObject.on(eventType, newProps[key]);
                }
            } else {
                var olKey1 = (0, _fp).startsWith("_", key) ? key.substring(1) : key;
                applyProp(olObject, olKey1, newProps[key]);
            }
        }
    }, (0, _fp).keys(newProps));
};
/**
 * This function is a no-op, it's just a type guard
 * It allows to force an instance to be considered by typescript
 * as being of a type from the catalogue
 * @param type
 * @param instance
 * @returns
 */ var getAs = function(_type, instance) {
    return instance;
};
var defaultAttach = function(parent, child) {
    if (!child) throw error001();
    var _MetaOlFiber = parent[MetaOlFiber], parentKind = _MetaOlFiber.kind;
    var _MetaOlFiber1 = child[MetaOlFiber], childKind = _MetaOlFiber1.kind;
    switch(parentKind){
        case "Map":
            {
                switch(childKind){
                    case "View":
                        getAs("olMap", parent).setView(getAs("olView", child));
                        return function(newParent) {
                            return getAs("olMap", newParent).unset("view");
                        }; // Dubious at best
                    case "Layer":
                        getAs("olMap", parent).addLayer(getAs("olLayerLayer", child));
                        return function(newParent, newChild) {
                            return getAs("olMap", newParent).removeLayer(getAs("olLayerLayer", newChild));
                        };
                    case "Control":
                        getAs("olMap", parent).addControl(getAs("olControlControl", child));
                        return function(newParent, newChild) {
                            return getAs("olMap", newParent).removeControl(getAs("olControlControl", newChild));
                        };
                    case "Interaction":
                        getAs("olMap", parent).addInteraction(getAs("olInteractionInteraction", child));
                        return function(newParent, newChild) {
                            return getAs("olMap", newParent).removeInteraction(getAs("olInteractionInteraction", newChild));
                        };
                    case "Overlay":
                        getAs("olMap", parent).addOverlay(getAs("olOverlay", child));
                        return function(newParent, newChild) {
                            return getAs("olMap", newParent).removeOverlay(getAs("olOverlay", newChild));
                        };
                    default:
                        throw error002(parentKind, childKind);
                }
            }
        case "Layer":
            {
                switch(childKind){
                    case "Source":
                        getAs("olLayerLayer", parent).setSource(// getAs("olSourceSource", child)
                        getAs("olSourceVector", child));
                        return function(newParent, _newChild) {
                            return getAs("olLayerLayer", newParent).unset("source");
                        }; // Dubious at best
                    default:
                        throw error002(parentKind, childKind);
                }
            }
        case "Source":
            {
                switch(childKind){
                    case "Feature":
                        getAs("olSourceVector", parent).addFeature(getAs("olFeature", child));
                        return function(newParent, newChild) {
                            return getAs("olSourceVector", newParent).removeFeature(getAs("olFeature", newChild));
                        }; // Dubious at best
                    case "Source":
                        getAs("olSourceCluster", parent).setSource(getAs("olSourceVector", child));
                        return function(newParent, _newChild) {
                            return getAs("olSourceCluster", newParent).unset("source");
                        }; // Dubious at best
                    default:
                        throw error002(parentKind, childKind);
                }
            }
        case "Feature":
            {
                switch(childKind){
                    case "Geom":
                        getAs("olFeature", parent).setGeometry(// getAs("olGeomGeometry", child)
                        getAs("olGeomGeometryCollection", child));
                        return function(newParent, _newChild) {
                            return getAs("olFeature", newParent).unset("geometry");
                        }; // Dubious at best
                    default:
                        throw error002(parentKind, childKind);
                }
            }
        default:
            throw error002(parentKind, childKind);
    }
};
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
// Hot Config functions
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
/// ////////////////////////////////////////////////////////////////////////////
var getPublicInstance = function(instance) {
    if (!instance) throw error001();
    return instance;
};
// Not used as of today, feel free to implement something cool instead of this
var getRootHostContext = function(_rootContainerInstance) {
    return emptyObject;
};
// Not used as of today, feel free to implement something cool instead of this
var getChildHostContext = function(parentHostContext, type, _rootContainerInstance) {
    return typeof parentHostContext === "string" ? "".concat(parentHostContext, ".").concat(type) : type;
};
var prepareForCommit = function(_containerInfo) {
    return null;
};
var resetAfterCommit = function(_containerInfo) {};
var createInstance = function(type, props, _rootContainerInstance, _hostContext, _internalInstanceHandle) {
    var olObject;
    var kind;
    if (type === "primitive") {
        // <primitive/> Elements like in react three fiber
        var object = props.object;
        olObject = object;
        kind = null;
    } else if (type === "new") {
        // <new/> Elements like in react three fiber
        var TheObjectClass = props.object, args = props.args;
        olObject = _construct(TheObjectClass, _toConsumableArray(args));
        kind = null;
    } else {
        // <olMap/> and all other similar elements from ol
        var args1 = props.args, constructFrom = props.constructFrom, attach = props.attach, onUpdate = props.onUpdate, children = props.children, otherProps = _objectWithoutProperties(props, [
            "args",
            "constructFrom",
            "attach",
            "onUpdate",
            "children"
        ]);
        var target = _catalogue.catalogue[type];
        if ((0, _fp).isNil(target)) {
            // Not found
            throw new Error("React-Openlayers-Fiber Error: ".concat(type, " is not exported by ol. Use extend to add it if needed."));
        } else if ((0, _fp).isNil(constructFrom)) {
            // No constructFrom prop (most common)
            var initialProps = (0, _fp).flow((0, _fp).pickBy(function(_value, propKey) {
                return propKey.substr(0, 7) === "initial";
            }), (0, _fp).mapKeys(function(propKey) {
                return (0, _fp).lowerFirst(propKey.substr(7));
            }))(otherProps);
            var objectProps = _objectSpread({}, initialProps, (0, _fp).mapKeys(function(propKey) {
                return (0, _fp).startsWith("_", propKey) ? propKey.substring(1) : propKey;
            }, (0, _fp).pickBy(function(_value, propKey) {
                return propKey.substr(0, 7) !== "initial";
            }, otherProps)));
            if ((0, _fp).isNil(args1)) {
                // No args, simple ol object with a single options object arg
                olObject = new target.object(objectProps);
                kind = target.kind;
            } else if ((0, _fp).isArray(args1)) {
                // Args array
                olObject = _construct(target.object, _toConsumableArray(args1));
                kind = target.kind;
            } else {
                // Single argument
                olObject = new target.object(_objectSpread({}, objectProps, args1));
                kind = target.kind;
            }
        } else if ((0, _fp).isFunction(target.object[constructFrom])) {
            // constructFrom prop is present
            // The static field exists on the class
            olObject = target.object[constructFrom].apply(_this, _toConsumableArray(args1));
            kind = target.kind;
        } else {
            // Static constructForm does not exist
            throw new Error("React-Openlayers-Fiber Error: ".concat(constructFrom, " is not a constructor for ").concat(target));
        }
        olObject[MetaOlFiber] = {
            kind: kind,
            type: type,
            attach: attach
        };
        applyProps(olObject, otherProps, {}, true);
    }
    return olObject;
};
var finalizeInitialChildren = function(_parentInstance, _type, _props, _rootContainerInstance, _hostContext) {
    return false;
};
var prepareUpdate = function(_instance, _type, oldProps, newProps, _rootContainerInstance, _hostContext) {
    var oldKeys = (0, _fp).keys(oldProps);
    var newKeys = (0, _fp).keys(newProps);
    // keys have same length
    if ((0, _fp).size(oldKeys) !== (0, _fp).size(newKeys)) {
        return true;
    } // keys are the same
    if (oldKeys.some(function(value, index) {
        return newKeys[index] !== value;
    })) {
        return true;
    }
    return oldKeys.filter(function(key) {
        return key !== "children";
    }).some(function(key) {
        return oldProps[key] !== newProps[key];
    });
};
var shouldSetTextContent = function(_type, _props) {
    return false;
};
// const shouldDeprioritizeSubtree = (_type: Type, _props: Props): boolean => {
//   return false;
// };
var createTextInstance = function(_text, _rootContainerInstance, _hostContext, _internalInstanceHandle) {
    return null;
};
// const scheduleTimeout:
//   | ((handler: TimerHandler, timeout: number) => TimeoutHandle | NoTimeout)
//   | null = isFunction(setTimeout) ? setTimeout : null;
// const cancelTimeout: ((handle: TimeoutHandle | NoTimeout) => void) | null =
//   isFunction(clearTimeout) ? clearTimeout : null;
var scheduleTimeout = setTimeout;
var cancelTimeout = clearTimeout;
var noTimeout = -1;
var commitTextUpdate = function(_textInstance, _oldText, _newText) {};
var commitMount = function(_instance, _type, _newProps, _internalInstanceHandle) {};
var removeChild = function(parent, child // | TextInstance | SuspenseInstance // FIXME one day
) {
    if (!child) throw error001();
    var _MetaOlFiber = child[MetaOlFiber], attach = _MetaOlFiber.attach, detach = _MetaOlFiber.detach;
    if ((0, _fp).isFunction(detach)) {
        detach(parent, child);
    } else if ((0, _fp).isString(attach)) {
        // eslint-disable-next-line no-param-reassign
        (parent)[attach] = undefined;
        // eslint-disable-next-line no-param-reassign
        delete parent[attach];
    } else {
        throw new Error("React-Openlayers-Fiber Error: Couldn't remove this child from this container. You can specify how to detach this type of child (\"".concat(child.constructor.name, "\") from this type of container (\"").concat(parent.constructor.name, "\") using the \"attach\" props."));
    }
};
var removeChildFromContainer = function(_container, child) {
    // Probably not neded
    // There can only be one map in its parent div
    (child).setTarget(undefined);
    child.unset("target");
};
var appendChild = function(parent, child) {
    if (!child) throw error001();
    var attach = child[MetaOlFiber].attach;
    // eslint-disable-next-line no-param-reassign
    child[MetaOlFiber].parent = parent;
    if ((0, _fp).isNil(attach)) {
        // eslint-disable-next-line no-param-reassign
        child[MetaOlFiber].detach = defaultAttach(parent, child);
    } else if ((0, _fp).isString(attach)) {
        var ref2, ref1;
        var setterGeneric = (ref2 = parent) === null || ref2 === void 0 ? void 0 : ref2.set;
        var setterSpecific = (ref1 = parent) === null || ref1 === void 0 ? void 0 : ref1["set".concat((0, _fp).upperFirst(attach))];
        if ((0, _fp).isFunction(setterSpecific)) {
            // Example:   source.setLayer(x)
            setterSpecific.bind(parent)(child);
            // eslint-disable-next-line no-param-reassign
            child[MetaOlFiber].detach = function(newParent, newChild) {
                var ref;
                var unsetterSpecific = (ref = newParent) === null || ref === void 0 ? void 0 : ref["unset".concat((0, _fp).upperFirst(attach))];
                if ((0, _fp).isFunction(unsetterSpecific)) {
                    unsetterSpecific.bind(newParent)(newChild);
                } else {
                    setterSpecific.bind(newParent)(undefined);
                }
            };
        } else if ((0, _fp).isFunction(setterGeneric)) {
            // Example:   source.set("layer",x)
            setterGeneric.bind(parent)(attach, child);
            // eslint-disable-next-line no-param-reassign
            child[MetaOlFiber].detach = function(newParent, newChild) {
                var ref;
                var unsetterGeneric = (ref = newParent) === null || ref === void 0 ? void 0 : ref.unset;
                if ((0, _fp).isFunction(unsetterGeneric)) {
                    unsetterGeneric.bind(newParent)(attach, newChild);
                } else {
                    setterGeneric.bind(newParent)(attach, undefined);
                }
            };
        } else {
            // Example:   source["layer"] = x
            console.warn("React-Openlayers-Fiber Warning: Attaching the child ".concat(attach, " brutally because there is no setter on the object"));
            // eslint-disable-next-line no-param-reassign
            (parent)[attach] = child;
            // eslint-disable-next-line no-param-reassign
            child[MetaOlFiber].detach = function(newParent, _newChild) {
                // eslint-disable-next-line no-param-reassign
                (newParent)[attach] = undefined;
                // eslint-disable-next-line no-param-reassign
                delete newParent[attach];
            };
        }
    } else if ((0, _fp).isFunction(attach)) {
        // eslint-disable-next-line no-param-reassign
        child[MetaOlFiber].detach = attach(parent, child, parent, child);
    } else {
        throw new Error("React-Openlayers-Fiber Error: Unsupported \"attach\" type.");
    }
};
// Code from react-three-fiber : https://github.com/pmndrs/react-three-fiber/blob/master/src/renderer.tsx#L450
function switchInstance(instance, type, newProps, fiber) {
    var parent = instance[MetaOlFiber].parent;
    var newInstance = createInstance(type, newProps, null, null, fiber);
    if ((0, _fp).isNil(parent)) {
        if (type === "olMap") {
            console.warn("React-Openlayers-Fiber Warning: Trying to switch olMap! This is poorly supported for now, it will only cause problems if you change the args of the olMap between renders.");
        } else {
            throw new Error("React-Openlayers-Fiber Error: Trying to switch instance which has no parent!");
        }
    } else {
        removeChild(parent, instance);
        appendChild(parent, newInstance);
    }
    // This evil hack switches the react-internal fiber node
    // https://github.com/facebook/react/issues/14983
    // https://github.com/facebook/react/pull/15021
    [
        fiber,
        fiber.alternate
    ].forEach(function(theFiber) {
        if (theFiber !== null) {
            // eslint-disable-next-line no-param-reassign
            theFiber.stateNode = newInstance;
            if (theFiber.ref) {
                if (typeof theFiber.ref === "function") theFiber.ref(newInstance);
                else theFiber.ref.current = newInstance;
            }
        }
    });
}
var commitUpdate = function(instance, _updatePayload, type, oldProps, newProps, internalInstanceHandle) {
    var olObject = instance;
    // This is a data object, let's extract critical information about it
    var tmp = newProps.args, argsNew = tmp === void 0 ? [] : tmp, onUpdate = newProps.onUpdate, children = newProps.children, restNew = _objectWithoutProperties(newProps, [
        "args",
        "onUpdate",
        "children"
    ]); // Had to add the "as any" after moving to ol 6.6.0, which uses its own type definitions
    var tmp1 = oldProps.args, argsOld = tmp1 === void 0 ? [] : tmp1, restOld = _objectWithoutProperties(oldProps, [
        "args"
    ]); // Had to add the "as any" after moving to ol 6.6.0, which uses its own type definitions;
    // If it has new props or arguments, then it needs to be re-instanciated
    var hasNewArgs = false;
    if ((0, _fp).isArray(argsNew)) {
        if (!(0, _fp).isArray(argsOld)) {
            hasNewArgs = true;
        } else {
            hasNewArgs = argsNew.some(function(value, index) {
                return (0, _fp).isPlainObject(value) ? Object.entries(value).some(function(param) {
                    var _param = _slicedToArray(param, 2), key = _param[0], val = _param[1];
                    return val !== argsOld[index][key];
                }) : value !== argsOld[index];
            });
        }
    } else if ((0, _fp).isPlainObject(argsNew)) {
        if (Array.isArray(argsOld)) {
            hasNewArgs = true;
        } else {
            hasNewArgs = Object.entries(argsNew).some(function(param) {
                var _param = _slicedToArray(param, 2), key = _param[0], val = _param[1];
                return val !== argsOld[key];
            });
        }
    } else {
        throw Error("Args should be an Array or an object");
    }
    if (hasNewArgs) {
        // Next we create a new instance and append it again
        switchInstance(instance, type, newProps, internalInstanceHandle);
    } else {
        // Otherwise just overwrite props
        applyProps(olObject, restNew, restOld, false);
    }
    if (typeof onUpdate === "function") {
        onUpdate(olObject);
    }
};
var insertInContainerBefore = function(container, child, _beforeChild) {
    if (!child) throw error001();
    // eslint-disable-next-line no-param-reassign
    child[MetaOlFiber].parent = container;
// There can only be one map in its parent div
};
var resetTextContent = function(_instance) {};
var insertBefore = function(parentInstance, childInstance, _beforeChild) {
    appendChild(parentInstance, childInstance);
};
var appendInitialChild = function(parentInstance, childInstance) {
    return appendChild(parentInstance, childInstance);
};
var appendChildToContainer = function(_container, _child) {
// This would link the map to it's parent div container.
// But this is already done in the Map component anyway so not needed here
};
var hideInstance = function(instance) {
    var kind = instance[MetaOlFiber].kind;
    switch(kind){
        case "Layer":
            {
                getAs("olLayerLayer", instance).setVisible(false);
                break;
            }
        default:
            {
                throw new Error("React-Openlayers-Fiber Error: Can't hide things that are not layers");
            }
    }
};
var unhideInstance = function(instance, _props) {
    var kind = instance[MetaOlFiber].kind;
    switch(kind){
        case "Layer":
            {
                getAs("olLayerLayer", instance).setVisible(true);
                break;
            }
        default:
            {
                throw new Error("React-Openlayers-Fiber Error: Can't unhide things that are not layers");
            }
    }
};
var hideTextInstance = function() {
    throw new Error("React-Openlayers-Fiber Error: Text is not allowed in the react-openlayers-fiber tree. You may have extraneous whitespace between components.");
};
var unhideTextInstance = function() {
    throw new Error("React-Openlayers-Fiber Error: Text is not allowed in the react-openlayers-fiber tree. You may have extraneous whitespace between components.");
};
var reconciler = (0, _reactReconciler).default({
    // List from ./node_modules/react-reconciler/cjs/react-reconciler-persistent.development.js
    // -------------------
    getPublicInstance: getPublicInstance,
    getRootHostContext: getRootHostContext,
    getChildHostContext: getChildHostContext,
    prepareForCommit: prepareForCommit,
    resetAfterCommit: resetAfterCommit,
    createInstance: createInstance,
    appendInitialChild: appendInitialChild,
    finalizeInitialChildren: finalizeInitialChildren,
    prepareUpdate: prepareUpdate,
    shouldSetTextContent: shouldSetTextContent,
    // shouldDeprioritizeSubtree,
    createTextInstance: createTextInstance,
    // -------------------
    scheduleTimeout: scheduleTimeout,
    cancelTimeout: cancelTimeout,
    noTimeout: noTimeout,
    now: _scheduler.unstable_now,
    // -------------------
    isPrimaryRenderer: false,
    // warnsIfNotActing: true,
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    // -------------------
    // DEPRECATED_mountResponderInstance: noOp,
    // DEPRECATED_unmountResponderInstance: noOp,
    // getFundamentalComponentInstance: noOp,
    // mountFundamentalComponent: noOp,
    // shouldUpdateFundamentalComponent: noOp,
    // getInstanceFromNode: noOp,
    // getInstanceFromScope: () => noOp,
    // beforeRemoveInstance: noOp,
    // -------------------
    //      Mutation
    //     (optional)
    // -------------------
    appendChild: appendChild,
    appendChildToContainer: appendChildToContainer,
    commitTextUpdate: commitTextUpdate,
    commitMount: commitMount,
    commitUpdate: commitUpdate,
    insertBefore: insertBefore,
    insertInContainerBefore: insertInContainerBefore,
    removeChild: removeChild,
    removeChildFromContainer: removeChildFromContainer,
    resetTextContent: resetTextContent,
    hideInstance: hideInstance,
    hideTextInstance: hideTextInstance,
    unhideInstance: unhideInstance,
    unhideTextInstance: unhideTextInstance,
    preparePortalMount: noOp,
    queueMicrotask: queueMicrotask
});
function render(what, where) {
    var container;
    if (instances.has(where)) {
        container = instances.get(where);
    } else {
        container = reconciler.createContainer(where, 0, false, null);
        instances.set(where, container);
    }
    reconciler.updateContainer(what, container, null, function() {
        return null;
    });
    return reconciler.getPublicRootInstance(container);
}
